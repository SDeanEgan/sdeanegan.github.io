---
tags: [Rust Project]
---
## Sixth Status Post

*The book* is now more than half completed! Soon I'll be moving on to the first of the two larger project chapters, but before that there was still a bit more needed. This time around reading material was split between more complex tools and simpler logistical practices. 

Generics, traits, and lifetimes are more modern principles, presented in chapter ten. An easy way to sum them all up might be to say that they can be used to extend the syntax of declarations, definitions, and signatures to allow for more reusable constructions of code or to better clarify the intended functionality across data structures and functions. More specifically, we can use traits to repurpose code across our data structures and even in trait bounds to align what kind of structures we intend for our functions and methods. Generics allow us to make our code more agnostic to the types of the data it can be used for. By using similar syntax we can even incorporate information about where (in what scope) our references are intended to remain valid via lifetimes. Of course, annotating lifetimes would be a new practice for anyone who's new to Rust, but thanks to the short system of rules called lifetime elision the necessary annotation can be inferred much of the time, similar to type inference. 

Things were a bit easier with chapter eleven. It's much faster to learn how to create code tests, especially with how Rust makes incorporating tests brief. Include a scope for a module called tests, and annotate this with `#[cfg(test)]`, define some test functions which use `assert!` and are themselves annotated with `#[test]`. You can use `cargo test` - the same package manager as everything else - to see the results, and to keep things fast the tests run with multithreading by default. I thought this was particularly great. Just to have as a quick reference [I also included a `tests` project in the repository](https://github.com/SDeanEgan/rust-lang.book/tree/main/tests). 

Material from these past two weeks, chapters seven through eleven, will be seeing more review with the upcoming project, which will create a command line program similar to grep. After that, chapter thirteen will explore iterators and closures but also adds further improvements for the project. I plan to take my time with the material for this next week. I'm particularly interested to see how *the book* teaches the use of input/output and system interaction for this language. To maybe save a little time, I'm planning on taking active notes about my thoughts that I can use on the upcoming post. 