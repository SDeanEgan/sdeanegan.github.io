---
tags: [Rust Project]
---
## Thirteenth Status Post

Things have come a long way now, but we've made it far enough to find that there's a whole world ahead of us. I decided I wanted to include one more status post as a nicety to the project before next week's final report. This is because a primary goal for learning about any programming language should be what you want to do with it once you've got it down. So I spent some time looking into the resources that I can use to get closer to either independent or collaborative work with Rust. There's amazing breadth of sites, tools, and texts provided by the community to get excited about, and I want to share what I've found.

Once you've worked through *The Rust Programming Language*, you're ready to start exploring how Rust is used in different contexts. The next steps usually involve practicing with small examples, working through real-world exercises, and understanding the broader ecosystem of tools and libraries that support the language.

A good place to begin is [Rust by Example](https://doc.rust-lang.org/stable/rust-by-example/). This resource contains small, self-contained examples that show how different features of Rust work. It is organized by topic and is useful for reinforcing what you've already seen. However, even though this is a place to run some code I would use Rust by Example as a way to jog my memory about a particular area of the language. For something more like structured exercises with feedback, [Exercism's Rust track](https://exercism.org/tracks/rust) offers programming problems that focus on common Rust concepts, and they promote that you can get feedback from mentors on your solutions.

As your understanding of the language grows, it helps to learn more about how Rust is used to write real programs. [Effective Rust](https://effective-rust.com/title-page.html) provides a set of guidelines on how to write code that follows the conventions of the Rust community. These recommendations are focused on readability, maintainability, and safety. This is the most likely learning resource to be my next stop. The text continues a long-standing lineage of works to help intermediate programmers. Similarly, [Rust Design Patterns](https://rust-unofficial.github.io/patterns/) collects examples of idiomatic Rust code, showing common ways of solving problems using the language.

After completing the main chapters of *the book*, some of the additional tools provided in appendices seemed worth mentioning as well. The `clippy` tool runs a set of lints to catch common mistakes or suggest improvements to your code. `rustfmt` automatically formats your code according to Rust's style guidelines, and `rustfix` applies suggestions from the compiler to help you fix warnings. These tools are integrated with the compiler and cargo, and are popularly used as part of the development workflow. 

For those interested in going deeper there is much more than just beginner friendly material available. The [Rustonomicon](https://doc.rust-lang.org/nomicon/) explains how Rust works under the hood. It covers unsafe code, lifetimes, and memory management in detail. This is useful if you're writing low-level code or working on performance-critical parts of a system. It also received recommendation as a resource in *the book* on a couple of occasions. Another resource worth checking out is [Too Many Linked Lists](https://rust-unofficial.github.io/too-many-lists/), which shows the challenges of building different kinds of linked lists in Rust and serves as an exercise in understanding ownership and borrowing.

Finally, the Rust community provides several ways to stay up to date and get support. [This Week in Rust](https://this-week-in-rust.org/) is a weekly newsletter that includes updates, learning materials, and links to new libraries. The [users.rust-lang.org](https://users.rust-lang.org/) forum is a place to ask technical questions or get feedback on your projects, and the [Rust Discord](https://discord.gg/rust-lang) server has channels for both beginners and advanced users. This is where I would likely start to try and support the development of the language directly. 

While I feel like these examples run a good gamut, this really only scratches the surface for what is available. In the brief time I've spent I've been really impressed by the cool libraries and the huge repositories of work openly shared by the community. Soon, I'm going to be drawing some conclusions, because a phase of the growth is ending, but I'm also happy. Nothing is over yet.